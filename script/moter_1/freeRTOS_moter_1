#include <Arduino.h>
#include <FreeRTOS.h>

#define A_1A 7
#define A_1B 6
#define B_1A 4
#define B_1B 5
#define ECHO 8
#define TRIG 9

int speed = 200;

int greenButton = 2;
int redButton = 3;

bool greenState = false; // 전진 상태 저장
bool redState = false; // 후진 상태 저장
bool stopFlag = false; // 거리로 인한 정지 상태 저장

QueueHandle_t motorQueue; // 모터 제어 명령을 전달하는 Queue

typedef enum {
  MOTOR_STOP,
  MOTOR_FORWARD,
  MOTOR_BACKWARD
} MotorCommand;

// 모터 제어 Task
void MotorControlTask(void *pvParameters) {
  MotorCommand command;
  
  pinMode(A_1A, OUTPUT);
  pinMode(A_1B, OUTPUT);
  pinMode(B_1A, OUTPUT);
  pinMode(B_1B, OUTPUT);
  
  while (1) {
    if (xQueueReceive(motorQueue, &command, portMAX_DELAY) == pdPASS) { // Queue로부터 명령을 받음
      if (stopFlag) { // 만약 정지 상태라면
        command = MOTOR_STOP; // 강제로 멈추기
      }

      switch (command) {
        case MOTOR_FORWARD:
          // 전진
          analogWrite(A_1A, speed);
          analogWrite(A_1B, 0);
          analogWrite(B_1A, speed);
          analogWrite(B_1B, 0);
          break;
          
        case MOTOR_BACKWARD:
          // 후진
          analogWrite(A_1A, 0);
          analogWrite(A_1B, speed);
          analogWrite(B_1A, 0);
          analogWrite(B_1B, speed);
          break;
          
        case MOTOR_STOP:
        default:
          // 정지
          analogWrite(A_1A, 0);
          analogWrite(A_1B, 0);
          analogWrite(B_1A, 0);
          analogWrite(B_1B, 0);
          break;
      }
    }
  }
}

// 전진 버튼 Task
void ForwardTask(void *pvParameters) {
  pinMode(greenButton, INPUT_PULLUP);
  bool lastState = HIGH;
  
  while (1) {
    bool currentState = digitalRead(greenButton);

    // 버튼을 눌렀을 때 상태를 변경 (전진 On/Off 토글)
    if (lastState == HIGH && currentState == LOW) {
      greenState = !greenState;
      redState = false; // 후진 모드 해제

      MotorCommand command = greenState ? MOTOR_FORWARD : MOTOR_STOP;
      xQueueSend(motorQueue, &command, portMAX_DELAY);
      delay(100); // 버튼 디바운싱 처리
    }

    lastState = currentState;
    vTaskDelay(pdMS_TO_TICKS(100));
  }
}

// 후진 버튼 Task
void BackwardTask(void *pvParameters) {
  pinMode(redButton, INPUT_PULLUP);
  bool lastState = HIGH;
  
  while (1) {
    bool currentState = digitalRead(redButton);

    // 버튼을 눌렀을 때 상태를 변경 (후진 On/Off 토글)
    if (lastState == HIGH && currentState == LOW) {
      redState = !redState;
      greenState = false; // 전진 모드 해제

      MotorCommand command = redState ? MOTOR_BACKWARD : MOTOR_STOP;
      xQueueSend(motorQueue, &command, portMAX_DELAY);
      delay(100); // 버튼 디바운싱 처리
    }

    lastState = currentState;
    vTaskDelay(pdMS_TO_TICKS(100));
  }
}

// 초음파 거리 측정 Task
void UltrasonicTask(void *pvParameters) {
  pinMode(TRIG, OUTPUT);
  pinMode(ECHO, INPUT);

  while (1) {
    // 초음파 트리거 신호 발생
    digitalWrite(TRIG, LOW);
    delayMicroseconds(2);
    digitalWrite(TRIG, HIGH);
    delayMicroseconds(10);
    digitalWrite(TRIG, LOW);

    // 초음파 반사 신호 수신
    long duration = pulseIn(ECHO, HIGH);
    long distance = duration / 58;

    Serial.print("Distance : ");
    Serial.print(distance);
    Serial.println("cm");

    // 거리가 10cm 이하일 때 정지 상태로 변경
    if (distance > 0 && distance < 10) {
      stopFlag = true; // 정지 상태로 설정

      // Queue에 정지 명령 전송
      MotorCommand command = MOTOR_STOP;
      xQueueSend(motorQueue, &command, portMAX_DELAY);
    } else {
      stopFlag = false; // 안전 거리일 경우 계속 진행 가능
    }
    
    vTaskDelay(pdMS_TO_TICKS(200)); // 200ms마다 초음파 측정
  }
}

void setup() {
  Serial.begin(9600);

  motorQueue = xQueueCreate(5, sizeof(MotorCommand)); // MotorCommand를 저장하는 Queue 생성

  // Task 생성
  xTaskCreate(MotorControlTask, "MotorControl", 128, NULL, 2, NULL);
  xTaskCreate(ForwardTask, "Forward", 128, NULL, 1, NULL);
  xTaskCreate(BackwardTask, "Backward", 128, NULL, 1, NULL);
  xTaskCreate(UltrasonicTask, "Ultrasonic", 128, NULL, 3, NULL);

  vTaskStartScheduler(); // FreeRTOS 스케줄러 시작
}

void loop() {
  // FreeRTOS가 모든 Task를 관리하므로 여기는 필요하지 않음.
}
